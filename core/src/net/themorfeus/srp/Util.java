package net.themorfeus.srp;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import net.themorfeus.srp.render.FrameBufferManager;
import net.themorfeus.srp.render.shaders.ShaderHelper;

import java.util.HashMap;
import java.util.Random;

/**
 * Various utilities
 */
public class Util {

    /**
     * Path to font file
     */
    public static final String FONT_FILE = "bbc.ttf";

    /**
     * Lookup for less memory usage
     */
    private static HashMap<Integer, BitmapFont> fonts;

    /**
     * @return BitmapFont with the given size, generated by freetype font generator
     */
    public static BitmapFont getFont(int size){
        if(fonts==null) fonts = new HashMap<Integer, BitmapFont>();
        if(!fonts.containsKey(size)){
            FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal(FONT_FILE));
            FreeTypeFontGenerator.FreeTypeFontParameter parameter = new FreeTypeFontGenerator.FreeTypeFontParameter();
            parameter.size = size;
            parameter.genMipMaps = true;
            //WARNING: this is a temporary fix, and may not work for all fonts!
            parameter.spaceY = -size;
            parameter.magFilter = Texture.TextureFilter.MipMapLinearLinear;
            parameter.minFilter = Texture.TextureFilter.MipMapLinearLinear;


            fonts.put(size, generator.generateFont(parameter));
            generator.dispose();
        }

        return fonts.get(size);
    }

    public static void clearFonts(){
        for(BitmapFont f : fonts.values()){
            f.dispose();
        }
        fonts.clear();
    }



    /**
     * Lookup for less memory usage
     */
    private static HashMap<String, Float[]> colorCache = new HashMap<String, Float[]>();

    /**
    * @return an array of floats (R, G, B) of the color written in hex format
    */
    public static float[] getColorFromHex(String hex){
        if(hex.startsWith("#"))hex = hex.substring(1);
        if(hex.length()!=6)return new float[]{1,0,0};

        if(colorCache.containsKey(hex)){
            Float[] color = colorCache.get(hex);
            return new float[]{color[0], color[1], color[2]};
        }

        int color;

        try{
            color = Integer.parseInt(hex, 16);
        }catch (Exception e){
            e.printStackTrace();
            return new float[]{1,0,0};
        }

        float red = color >> 16;
        float green = (color & 0xffff)>>8;
        float blue = (color) & 0xff;

        red /= 255f;
        green /= 255f;
        blue /= 255f;
        colorCache.put(hex, new Float[]{red, green, blue});
        return new float[]{red, green, blue};
    }

    /**
     * Clamps the given value between the min and max values
     * @param val The value to clamp
     * @param min Minimal value
     * @param max Maximal value
     */
    public static float clamp(float val, float min, float max){
        if(val<min)return min;
        if(val>max)return max;
        return val;
    }

    /**
     * Splits given tileset and returns a textureRegion with given margin. Used to avoid texture tearing.
     * @param t Texture to split
     * @param cellWidth the width of a single texture cell (with margin)
     * @param cellHeight the height of a single texture cell (with margin)
     * @param textureWidth the width of a texture (without margin)
     * @param textureHeight the height of a texture (without margin)
     */
    public static TextureRegion[] splitUntearableTileset(Texture t, int cellWidth, int cellHeight, int textureWidth, int textureHeight){

        int columns = t.getWidth() / cellWidth;
        int rows = t.getHeight() / cellHeight;

        int gutterX = (cellWidth - textureWidth)/2;
        int gutterY = (cellHeight - textureHeight)/2;

        TextureRegion[] split = new TextureRegion[rows*columns];

        for(int y = 0; y<rows; y++){
            for(int x = 0; x<columns; x++){

                int tX = x * cellWidth;
                int tY = y * cellHeight;

                split[y*rows + x] = new TextureRegion(t, tX+gutterX, tY+gutterY, textureWidth, textureHeight);
            }
        }

        return split;
    }

    /**
     * Chooses a random element from the supplied list
     * @param items Objects to choose from
     * @return a random object from the supplied array
     */
    public static <E> E choose(E... items){
        return items[new Random().nextInt(items.length)];
    }

    /**
     * Creates a fullscreen quad to do the rendering of a FrameBuffers
     */
    public static Mesh createFullScreenQuad() {

        float[] verts = new float[20];
        int i = 0;

        verts[i++] = -1; // x1
        verts[i++] = -1; // y1
        verts[i++] = 0;
        verts[i++] = 0f; // u1
        verts[i++] = 0f; // v1

        verts[i++] = 1f; // x2
        verts[i++] = -1; // y2
        verts[i++] = 0;
        verts[i++] = 1f; // u2
        verts[i++] = 0f; // v2

        verts[i++] = 1f; // x3
        verts[i++] = 1f; // y2
        verts[i++] = 0;
        verts[i++] = 1f; // u3
        verts[i++] = 1f; // v3

        verts[i++] = -1; // x4
        verts[i++] = 1f; // y4
        verts[i++] = 0;
        verts[i++] = 0f; // u4
        verts[i++] = 1f; // v4

        Mesh mesh = new Mesh( true, 4, 0,  // static mesh with 4 vertices and no indices
                new VertexAttribute(VertexAttributes.Usage.Position, 3, "a_position"),
                new VertexAttribute(VertexAttributes.Usage.TextureCoordinates, 2, "a_texCoord"));

        mesh.setVertices( verts );
        return mesh;
    }
}
